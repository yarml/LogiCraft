# LogiCraft
A simple, strongly typed, language that compiles to minecraft datapacks

Checkout [design](design.md)

Still in prototype phase.

# Next Iteration Plan
For this next iteration, we will use a semi global struct called Context, which will
be a centralized center of information first filled by the lexer, then filled more and used by
the parser, semifier, and codegen. The output of the lexer, parser, and semifier all only contain
IDs within.

## Dictionary
To stay consistent with terminology and avoid confusing names, this is a dictionary containing different
syntax structures and what they are referref to by:
- Symbol: An alphanumeric name not composed of any parts, follows the regex [a-zA-Z_][a-zA-Z0-9_]*
- ModuleName: A sequence of symbols acting as a path to a specific file (e.g utils::math::geometry)
- Identifier: A symbol or sequence of symbols separated by :: which may optionally be absolute if it starts with :: (e.g geometry::sin, ::utils::math::geometry::sin, sin). The first symbol in the identifier must always be in scope unless the identifier is absolute.
- Name: An identifier or an identifier followed by member access or a name followed by member access (e.g player.health, ). The shape of a Name structure is Name { Identifier, Vec`<`Symbol`>` }.
- AbsoluteIdentifier: The absolute path of an identifier, resolved by the semifier. It inherits Location information from the Identifier it was built from. Can either be Local or Global.
- AbsoluteName: A Name with AbsoluteIdentifier instead, resolved by the semifier. It inherits Location information from the Name it was built from. Can either be Local or Global
- Type: Can either be Builtin or Declared(Identifier). This represents a Type as seen by the parser and lexer.
- ResolvedType: Can either be builtin or Declared, generated by the semifier, if declared specifies whether it is a product type with a list of fields with their names and references to their ResolvedType's, or a sum type with possible variants and their content specified the same as a product type.
- FinalType: Generated during codegen, contains a numerically indexed list of fields made up of only builtin atom types.

## Type System
The languae supports only Integers, Booleans, and Strings as base atomic types.

Product types can be built using structs, tagged sum types can be built using enums.

Types cannot be self referential.

This draft does not specify support for generic types.

## File
FileData will represent a source file, it owns the PathBuf representation of the path, and owns the source as a String.
A FileData can be refered to by multiple objects. FileData is immutable.

FileTable is the table that manages all FileData's. It allocates space for them, however, it only
keeps weak references, allowing the data it is referring to to be deallocated once it is no longer referenced.
FileData's in the table are referenced by their pat.

FileId is a type that encapsulates a strong reference to a specific FileData. As long as a FileId exists for
a FileData, the FileData exists.

## Symbol
Symbol will be what was referred to formely as Name, it should contain only the literal
representation of a symbol. It can be referenced by multiple SymbolId's. A Symbol is immutable.

SymbolTable is the type that manages all the symbols. It can allocate space for Symbol's.
The SymbolTable however does not keep a strong reference to its data, allowing it to be deallocated if nobody is
referring to it anymore(which should not happen). Symbol's in the table are indexed by their literal value.

SymbolId represents a combination between a strong reference to a Symbol, a FileId, and line and column information.
This object should never be made up, and all instances of SymbolInstance should contain data such that if it is
verified in the source code, that specific symbol will be found. As long as there is at least one SymbolId the Symbol it
is referring to exists.

## Module
A Module contains the FileId for the module it is referring to, in addition to a ModuleName, and a list of all the declarations
made within that module. Module's are first made by the Loader, a step after lexing each file which scans it for the modules it is declaring
and finds the appropriate files to lex and load next. After the Loader's stage, and the lexing stage in general, the declaration list is empty.
It is later populated by the parsing stage with nodes, and the semification stage with semantic information related to the Module(more in relevant chapters).
A Module is mutable.

ModuleName is a wrapper around a `Vec<String>` with convenience features.

A ModuleTable manages all Module's. It can allocate space for Module's. It does not however keep
strong references to its data, allowing it to be deallocated if nobody is referring to it anymore. Since
Module's are mutable, the table should be making RefCells. Module's in the
table are indexed by a ModuleName.

ModuleId is a strong reference to a Module.

### Data kept in Module
This is an exhaustive list of all data that needs to be kept within a Module:
- ModuleName
- FileId
- List of SymbolId's for all symbols declared within the module.
- List of Token's found in the module.
- List of ModuleNodeId's for all Node's generated by the parsing stage within this module
- UseMap for all use declarations made within this Module.
- List of FunctionId's declared within the Module.
- List of GlobVarId's declared within the Module.
- List of StructId's declared within the Module.

This data is filled as we move forward in the compiler pipeline, until Module's are resolved away and all merged
into a Program.

## Node
A ModuleNode represents a node that can be found in the top level of a module.

A FunctionNode represents a node that can be found in a function body.

### ModuleNode variants:
- ModDecl
- UseDecl
- FnDecl
- VarDecl
- StructDecl

### FunctionNode variants:
- VarDecl
- 

## Errors
There is one error enum which contains all the possible errors that could ever be returned by any
function from argument parsing to semifying.

The errors that are defined are as follows:
- InputError: Error reading input file
- OutputError: Error writing to output file
- RemoveError: Error while removing file/directory
- CreateDir: Error creating a directory
- DirExists: Expecting directory to not exist but it exists
- ConfigParse: Error while parsing config file
- Bug: Compiler bug

This list is non comprehensive, and this enum specifically we can leave its details out until implementation.

The guidelines in error management is that components should never quit due to an error, but return it in a Result, and the top level handlers that deal with the user interaction would be responsible for handling those errors.

## Possible Optimizations
We could drop all tables relating to analysis(lex, parse, sem) when done(This includes Symbols, Nodes, Modules, etc). Maybe we can have it as a compiler option
to opt in if memory is limited on the system.

Another one which is more important is multi threading, if we could lex multiple files in parallel it would be great. This would require
making Rc's into Arc's and Rc`<`RefCell`>`'s into Mutex's, but it is probably doable. Matter of fact may do so in the next draft. It would also be useful
if we have a compiler option for the maximum number of worker threads we could have.
