# ISA
## Registers
A scoreboard objective called "registers" contains all registers. Scoreboard are perfect since
mathematical operations can be done between them in an x86 style (first source operand is also destination).
Registers are named T<0..5>, S<0..5>. For a total of 16 registers. The calling convention specifies how these registers should be used.

## Data Location
Data location is the closest thing we have to a pointer in real computers, it consists of a storage name, and a path.
Datapacks normally only access data in their stack frame, or their local storage, however accessing arbitrary data is
also possible.

### Global Storage
Configuration that can be shared among multiple Logicraft datapacks can be found in the data storage `lc:config`.

Data that can be shared among multiple Logicraft datapacks can be found in the data storage `lc:data`

### Local Storage
Configuration of any datapack will be stored in the data storage `lc:config/<datapackid>`

Data of any datapack will be stored in the data storage `lc:data/<datapackid>`

### Stack
The stack is represented as a field `frames:[]` in the global storage, which is an array.
It is put in the global storage to allow for future expansions to Logicraft allowing cross datapack calls.
On each function call we prepend the array with an object of the form `{locals:[[]],fname:"...",source:"..."}`.
The layout of `locals` is determined on the fly at compile time.

On function exit we remove the first item in the array and return.

## Instructions
- Add Register, Register
- Sub Register, Register
- Mul Register, Register
- Div Register, Register
- Mod Register, Register
- Tell DataLocation

# Calling convention
## Registers
| Category | Function    | Saved by |
| -------- | ----------- | -------- |
| T        | Temporaries | Caller   |
| S        | Temporaries | Callee   |

## Call Storage
Function call storage that is used to pass other parameters is found in the global management storage as a field `params:[[]]`.

## Function Call Procedure
- Caller saves any T registers it is needing in its stack frame in a new sub-field called `presaved:[]`. The layout of `presaved` is made up  for each call at compile time.
- Caller fills call storage & T registers (checkout Arguments section) with parameters.
- Pass control to callee with macro context as call storage.
- Callee creates its stack frame with initial values for local variables and proper metadata.
- Callee saves any S registers it will use in its stack frame in a new sub-field called `postsaved:[]`. Tha layout of `postsaved` is made up on the fly for each function at compile time.

## Function Return Procedure
- Callee restores any S registers it previously saved.
- Callee removes its stack frame.
- Callee sets the return value(depends on type checkout Return Value section).
- Return control to caller.
- Caller moves return value to where it wants it to be.
- Caller restores any T registers it previously saved.

## Arguments
The first 6 integer or boolean arguments are passed through T registers. Other types of arguments and subsequent integer or boolean arguments are
stored in their order of declaration in the call storage.

## Return Value
If the return value is a single integer or boolean value, it is directly returned with the `return` command, and the caller is supposed
to extract it using `execute store`.

If there are 6 or less more integer or boolean return values, they are put in T registers.

Other types of return values, and subsequent integer or boolean return values are put in the call storage in their order of declaration.

# Interface
Compiler input:
- Source Code(with file structure metadata)
- Output destination(defaults to pwd)
- Output type (folder/Zip)
- Config:
  - LC version
  - datapack name
  - datapack version

Compiler Output:
- Datapack folder/Zip

# Semifier (Semantic Analyzer)
The semantic analyzer should ensure that the AST generated by the parser is valid, and would not emit any
error once passed to the codegen module.

Lexical errors and parsing errors should have already been caught by the lexer and parser respectively,
the kinds of errors that can still be contained within the AST at this point are use of non declared symbols
and type errors.

The Semifier first needs to make a list of all identifiers declared within each module, then verify that all the "use"
declaration within all modules point to valid identifiers. These declarations need to be kept track of with their type
as well, and the semifier must ensure that an identifier referencing a variable is not used like a function for
example, that function parameter types are respected. But this is done at a later stage of semification, the type
checking stage.

For type checking, the semifier needs both the aforementioned declaration list, and a local name resolver within function
bodies, that shares some logic with the declaration list, as it too needs to svae information about types, this time of
local variables. This is also the stage where call targets are verified to be functions and not variables, that parameters respect
their types etc.

There is an issue with determining the type of global variables using inference which I have just realised, Rust has this too I assume
or something similar since they force explicitely spelling the types of global variables, since the type inference that could be done
on the initial value would itself need the declaration list to be already done. There is 100% a way around this, and having the
semifier only report an error in case of circularity when trying to determin the type of a global, but I believe that a simpler approach
is doing what rust is doing and forrcing the user to specify the type.

If implementing the semifier is to be cut to steps, it should be as follows:
- Implement ProgDeclMap, a unit capable of keeping track of all global identifiers(functions and variables) alongside their mutability,
types, etc.
- Test ProgDeclMap, does it look like it works? Fix it.
- Implement LocalDeclMap, a unit similar to ProgDeclMap, except that it acts on local names instead of global indetifiers, can only contain
variables and their assosiated types.
- Implement SymbolChecker, which utilizes both ProgDeclMap, and LocalDeclMap to verify function bodies consistency.
- Verify all function bodies with their own SymbolResolver, report errors if they arrise.
- If no error arises, then we're done semifying, the semifier outputs the same AST except with all identifiers remapped to their global names,
an AST without ModDecl or UseDecl, functions of the AST have attached with them their SymbolResolver.
